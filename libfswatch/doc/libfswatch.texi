\input texinfo   @c -*-texinfo-*-

@c %**start of header
@setfilename libfswatch.info

@c Automake automatically updates version.texi to @set VERSION and @set UPDATED
@c to appropriate values.
@include version.texi

@settitle libfswatch @value{VERSION}

@c @finalout

@smallbook

@defcodeindex op

@paragraphindent 2
@c %**end of header

@copying
This manual is for @command{libfswatch} (version @value{VERSION},
@value{UPDATED}), a C/C++ library that encapsulates all the functionality of
@command{fswatch}, a cross-platform file change monitor with multiple backends,
including Apple OS X File System Events @acronym{API}, *BSD kqueue, Linux
inotify and a @command{stat}-based backend.

Copyright @copyright{} 2013-2015 Enrico M. Crisostomo

@quotation
Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license is
included in the section entitled `GNU Free Documentation License'.
@end quotation
@end copying

@setchapternewpage odd

@shorttitlepage libfswatch
@titlepage
@title libfswatch
@subtitle Cross-platform file change monitor C/C++ library with multiple backends
@subtitle for @command{libfswatch} version @value{VERSION}, @value{UPDATED}

@author Enrico M. Crisostomo

@c Include the Distribution inside the titlepage so that headings are turned
@c off.

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@c Output the table of contents at the beginning.
@summarycontents
@contents

@ifnottex
@node Top
@top fswatch
@insertcopying
@end ifnottex

@menu
* Introduction::
* The C++ API::
* The C API::
* GNU Free Documentation License::
* Index of Command Line Options::
* Index::

@end menu

@node Introduction
@chapter Introduction
@command{fswatch} is a cross-platform file change monitor currently supporting
the following monitors:

@itemize
@item
A monitor based on the @emph{FSEvents} @acronym{API} of Apple OS X.

@item
A monitor based on @emph{kqueue}, an event notification interface introduced in
FreeBSD 4.1 and supported on most *BSD systems (including OS X).

@item
A monitor based on @emph{inotify}, a Linux kernel subsystem that reports file
system changes to applications.

@item
A monitor which periodically stats the file system, saves file modification
times in memory and manually calculates file system changes, which can work on
any operating system where @command{stat} can be used.
@end itemize

The first releases of @command{fswatch} were monolithic, self-contained binaries
whose output was typically piped to other application for processing.  Given the
nature of the features provided by @command{fswatch}, however, we recognized the
need to expose this functionality through a library and the @command{libfswatch}
package was born.

@command{fswatch} is now built upon it and all its functionality is provided by
the @command{libfswatch} library, with the exception perhaps of some formatting
routines printing results to the standard output.

@section Available Bindings
@command{libfswatch} is a C++ library with C bindings which makes it available
to a wide range of programming languages.  If a programming language has C
bindings, then @command{libfswatch} can be used from it.  The C binding provides
all the functionality provided by the C++ implementation and it can be used as a
fallback solution when the C++ @acronym{API} cannot be used.

@section Relation between @command{fswatch} and @command{libfswatch}
Although @command{fswatch} uses functionality provided by @command{libfswatch}
and depends on it, @command{libfswatch} is currently a package nested into
@command{fswatch}.  If either component is updated, the whole package is, as
well as their version numbers are.  From the @acronym{GNU} Build System point of
view, the package version of @command{libfswatch} is always kept in sync with
@command{fswatch}'s.

The library @acronym{API} version, however, @emph{is not}, and it is the only
piece of information that should be kept into account when linking against
@command{libfswatch}.  Since we use @command{libtool} to build
@command{libfswatch}, we adopt @command{libtool}'s versioning scheme for library
interface versions.

@subsection @command{libtool}'s versioning scheme
@command{libtool}'s versioning scheme is described by three integers
@example
current:revision:age
@end example
where:
@itemize
@item
@command{current} is the most recent interface number implemented by the
library.

@item
@command{revision} is the implementation number of the current interface.

@item
@command{age} is the difference between the newest and the oldest interface that
the library implements.
@end itemize

@section The C and the C++ @acronym{API}
The C @acronym{API} is built on top of the C++ @acronym{API} but the two are
very different and the main difference reflect the differences between the two
languages.

The C++ @acronym{API} centres on the concept of @emph{monitor}, a class of
objects modelling the functionality of the file monitoring @acronym{API}.
Different monitor types are modelled as different classes inheriting from the
@command{fsw::monitor} abstract class, that is the type that defines the core
monitoring @acronym{API}.  @acronym{API} clients can pick the current platform's
default monitor, or choose a specific implementation amongst the available ones,
configure it and @emph{run} it.  When running, a monitor gathers file system
change events and communicates them back to the caller using a @emph{callback}.

The C @acronym{API}, on the other hand, centres on the concept of
@emph{monitoring session}.  A session internally wraps a monitor instance and
represents an opaque C bridge to the C++ monitor @acronym{API}.  Sessions are
identified by a @emph{session handle} and they can be thought as a sort of C
`fa@,{c}ade' of the C++ monitor class.  In fact there is an evident similarity
between the C library functions operating on a monitoring session and the
methods of the @command{monitor} class.

@section Thread Safety
The C++ @acronym{API} does not deal with thread safety explicitely.  Rather, it
leaves the responsibility of implementing a thread-safe use of the library to
the callers.  The C++ implementation has been designed in order to:

@itemize
@item
Encapsulate all the state of a monitor into its class fields.

@item
Perform no concurrent access control in methods or class fields.

@item
Guarantee that functions and @emph{static} methods are thread safe.
@end itemize

As a consequence, it is @emph{not} thread-safe to access a monitor's member, be
it a method or a field, from different threads concurrently.  The easiest way to
implement thread-safety when using @command{libfswatch}, therefore, is
segregating access to each monitor instance from a different thread.

The C @acronym{API}, a layer above the C++ @acronym{API}, has been designed in
order to provide the same basic guarantee:

@itemize
@item
Concurrently manipulating different monitoring sessions is thread safe.

@item
Concurrently manipulating the same monitoring session is @emph{not} thread safe.
@end itemize

There is an additional limitation which affects the C library only: the C
binding implementation internally uses @acronym{C++11} classes and keywords to
provide the aforementioned guarantees.  If compiler or library support is not
found when building @command{libfswatch} the library will still build, but those
guarantees will @emph{not} be honoured.  A warning such as the following will
appear in @command{configure}'s output to inform the user:

@smallexample
configure: WARNING: libfswatch is not thread-safe because the current
combination of compiler and libraries do not support the thread_local
storage specifier.
@end smallexample

@noindent
@xref{Thread-Safety of the C @acronym{API}}.

@section Reporting Bugs and Suggestions
@anchor{Reporting Bugs and Suggestions}
@cpindex bug
@cpindex bug report
@cpindex GitHub repository
@cpindex @command{fswatch}, repository
@cpindex @command{fswatch}, sources
If you find problems or have suggestions about this program or this manual,
please report them as new issues in the official GitHub repository of
@command{fswatch} at @uref{https://github.com/emcrisostomo/fswatch}.  If you
with you may contact the authors at the addresses listed in the @file{AUTHORS}
file.

When reporting a bug, please be sure to include as much detail as possible and
sufficient information to reproduce it.

@node The C++ API
@chapter The C++ @acronym{API}
The C++ @acronym{API} provides users an easy to use, object-oriented, common and
intuitive interface to a wide range of file monitoring @acronym{API}s.  This
@acronym{API} provides a common facade to a set of heterogeneous @acronym{API}s
that not only greatly simplifies their usage, but provides an indirection layer
that makes applications more portable: as far as there is an available monitor
in another platform, an existing application will @emph{just} work.

In reality, a monitor may have platform-specific behaviours that should be taken
into account when writing portable applications using this library.  This
differences complicate the task of writing portable applications that are truly
independent of the file monitoring @acronym{API} they may be using.  However,
monitors try to `compensate' for any behavioural difference across
implementations.

The typical @acronym{API} usage pattern is similar to the following:

@itemize
@item
An instance of a @command{monitor} is either created directly or through the
factory (@pxref{Monitor Registration and Discovery}).

@item
The monitor is configured according to the user needs (@pxref{Monitors}).

@item
The monitor is @emph{run} and change events are waited for.
@end itemize

@section Monitor Registration and Discovery
@anchor{Monitor Registration and Discovery} Since multiple monitor
implementations exist and the caller potentially ignores which monitors will be
available at run time, there must exist a way to query the @acronym{API} for the
list of available monitor and request a particular instance.  The
@command{monitor_factory} is an object factory class that provides basic monitor
@emph{registration} and @emph{discovery} functionality: @acronym{API} clients
can query the monitor registry to get a list of available monitors and get an
instance of one by @emph{type} or @emph{name}.

The @command{monitor_factory} class provides the following methods:

@table @command
@item static monitor * create_default_monitor
Creates a monitor of the default monitor type for the current platform with the
specified constructor parameters (@pxref{Monitors}).

@item static monitor * create_monitor
Creates a monitor of the specified type with the specified constructor
parameters (@pxref{Monitors}).  If the named monitor is not available, then
return @command{nullptr}.

@item static monitor * create_monitor_by_name
Creates a monitor of the specified type (by @var{name}) and constructor
parameters (@pxref{Monitors}).  If the named monitor is not available, then
return @command{nullptr}.

@item static std::vector<std::string> get_types()
Get the list of available monitor types.  The type name can then be used to get
a monitor instance by name using @command{create_monitor_by_name}.

@item static bool exists_type(const std::string& name)
Query whether the specified monitor exists.

@item static void register_type(const std::string& name, fsw_monitor_type type)
Register a monitor type in the list of available implementations.
@end table

@section Monitors
@anchor{Monitors}
To do.

The @command{monitor} class is central in the C++ @acronym{API}: it defines the
`contract' of every monitor and provides the means to create them.  A monitor is
a @emph{backend} which implements file monitoring using a specific @acronym{API}
or technique.

@node The C API
@chapter The C @acronym{API}

@section Thread-Safety of the C @acronym{API}
@anchor{Thread-Safety of the C @acronym{API}}

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@c Print option index
@node Index of Command Line Options
@appendix Index of Command Line Options
This appendix contains an index of all @command{fswatch} long command line
options.  The options are listed without the preceding double-dash.

@printindex op

@node Index
@unnumbered Index
@printindex cp

@bye
