<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>libfswatch: fsw::monitor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfswatch
   &#160;<span id="projectnumber">1.9.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefsw.html">fsw</a></li><li class="navelem"><a class="el" href="classfsw_1_1monitor.html">monitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classfsw_1_1monitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fsw::monitor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class of all monitors.  
 <a href="classfsw_1_1monitor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="monitor_8hpp_source.html">monitor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fsw::monitor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfsw_1_1monitor.png" usemap="#fsw::monitor_map" alt=""/>
  <map id="fsw::monitor_map" name="fsw::monitor_map">
<area href="classfsw_1_1fen__monitor.html" title="Solaris/Illumos monitor. " alt="fsw::fen_monitor" shape="rect" coords="0,56,133,80"/>
<area href="classfsw_1_1fsevents__monitor.html" title="OS X FSEvents monitor. " alt="fsw::fsevents_monitor" shape="rect" coords="143,56,276,80"/>
<area href="classfsw_1_1inotify__monitor.html" title="Solaris/Illumos monitor. " alt="fsw::inotify_monitor" shape="rect" coords="286,56,419,80"/>
<area href="classfsw_1_1kqueue__monitor.html" title="Solaris/Illumos monitor. " alt="fsw::kqueue_monitor" shape="rect" coords="429,56,562,80"/>
<area href="classfsw_1_1poll__monitor.html" title="stat()-based monitor. " alt="fsw::poll_monitor" shape="rect" coords="572,56,705,80"/>
<area href="classfsw_1_1windows__monitor.html" title="Windows monitor. " alt="fsw::windows_monitor" shape="rect" coords="715,56,848,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba09c75eb425a34848cf1511a5f2bc57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#aba09c75eb425a34848cf1511a5f2bc57">monitor</a> (std::vector&lt; std::string &gt; <a class="el" href="classfsw_1_1monitor.html#a2145c195fd74240392c276c1e05f8a1a">paths</a>, <a class="el" href="namespacefsw.html#aeec974e61cf25175d0e530cd3f504f81">FSW_EVENT_CALLBACK</a> *<a class="el" href="classfsw_1_1monitor.html#aaeb98ec82dfb122c73d51118ced25c4f">callback</a>, void *<a class="el" href="classfsw_1_1monitor.html#a31f7a7bde76c8b4487862298395a485e">context</a>=nullptr)</td></tr>
<tr class="memdesc:aba09c75eb425a34848cf1511a5f2bc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a monitor watching the specified <code>paths</code>.  <a href="#aba09c75eb425a34848cf1511a5f2bc57">More...</a><br /></td></tr>
<tr class="separator:aba09c75eb425a34848cf1511a5f2bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b082c84d771f601c98240ed6aa8775"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ab1b082c84d771f601c98240ed6aa8775">~monitor</a> ()</td></tr>
<tr class="memdesc:ab1b082c84d771f601c98240ed6aa8775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs a monitor instance.  <a href="#ab1b082c84d771f601c98240ed6aa8775">More...</a><br /></td></tr>
<tr class="separator:ab1b082c84d771f601c98240ed6aa8775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad170b85b262aa22e0cba907ab4b02271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad170b85b262aa22e0cba907ab4b02271"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ad170b85b262aa22e0cba907ab4b02271">monitor</a> (const <a class="el" href="classfsw_1_1monitor.html">monitor</a> &amp;orig)=delete</td></tr>
<tr class="memdesc:ad170b85b262aa22e0cba907ab4b02271"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copy constructible. <br /></td></tr>
<tr class="separator:ad170b85b262aa22e0cba907ab4b02271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205aeb4a9ad14f4a8cc16aed3e496f16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205aeb4a9ad14f4a8cc16aed3e496f16"></a>
<a class="el" href="classfsw_1_1monitor.html">monitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a205aeb4a9ad14f4a8cc16aed3e496f16">operator=</a> (const <a class="el" href="classfsw_1_1monitor.html">monitor</a> &amp;that)=delete</td></tr>
<tr class="memdesc:a205aeb4a9ad14f4a8cc16aed3e496f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copy assignable. <br /></td></tr>
<tr class="separator:a205aeb4a9ad14f4a8cc16aed3e496f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747619157af3f23f0f4f48e438af17a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a747619157af3f23f0f4f48e438af17a5">set_property</a> (const std::string &amp;name, const std::string &amp;value)</td></tr>
<tr class="memdesc:a747619157af3f23f0f4f48e438af17a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom property.  <a href="#a747619157af3f23f0f4f48e438af17a5">More...</a><br /></td></tr>
<tr class="separator:a747619157af3f23f0f4f48e438af17a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9209992c164ca241f32f3f0435a6ae39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a9209992c164ca241f32f3f0435a6ae39">set_properties</a> (const std::map&lt; std::string, std::string &gt; options)</td></tr>
<tr class="memdesc:a9209992c164ca241f32f3f0435a6ae39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the custom properties.  <a href="#a9209992c164ca241f32f3f0435a6ae39">More...</a><br /></td></tr>
<tr class="separator:a9209992c164ca241f32f3f0435a6ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdac1c160c6f4d02aeeee98f9c6afc2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#adcdac1c160c6f4d02aeeee98f9c6afc2">get_property</a> (std::string name)</td></tr>
<tr class="memdesc:adcdac1c160c6f4d02aeeee98f9c6afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a property.  <a href="#adcdac1c160c6f4d02aeeee98f9c6afc2">More...</a><br /></td></tr>
<tr class="separator:adcdac1c160c6f4d02aeeee98f9c6afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5121f8f7accc77a212853b6d84ca4fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a5121f8f7accc77a212853b6d84ca4fe4">set_latency</a> (double <a class="el" href="classfsw_1_1monitor.html#a8dd94758dcbd77755b9466a5adbcaec3">latency</a>)</td></tr>
<tr class="memdesc:a5121f8f7accc77a212853b6d84ca4fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the latency.  <a href="#a5121f8f7accc77a212853b6d84ca4fe4">More...</a><br /></td></tr>
<tr class="separator:a5121f8f7accc77a212853b6d84ca4fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab803cabf3d393c789338e5b7385e48e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ab803cabf3d393c789338e5b7385e48e7">set_fire_idle_event</a> (bool <a class="el" href="classfsw_1_1monitor.html#a31ffa5236ceca6bc9610f03104b03f1b">fire_idle_event</a>)</td></tr>
<tr class="memdesc:ab803cabf3d393c789338e5b7385e48e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <em>fire idle event</em> flag.  <a href="#ab803cabf3d393c789338e5b7385e48e7">More...</a><br /></td></tr>
<tr class="separator:ab803cabf3d393c789338e5b7385e48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599416921f439d4a02c156adee1c3643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a599416921f439d4a02c156adee1c3643">set_allow_overflow</a> (bool overflow)</td></tr>
<tr class="memdesc:a599416921f439d4a02c156adee1c3643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify buffer overflows as change events.  <a href="#a599416921f439d4a02c156adee1c3643">More...</a><br /></td></tr>
<tr class="separator:a599416921f439d4a02c156adee1c3643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eecd2653e537bdc74e6b396e6c517f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a9eecd2653e537bdc74e6b396e6c517f6">set_recursive</a> (bool <a class="el" href="classfsw_1_1monitor.html#ae63ee8c36aeffd3ecb00f9a26632b8f5">recursive</a>)</td></tr>
<tr class="memdesc:a9eecd2653e537bdc74e6b396e6c517f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively scan subdirectories.  <a href="#a9eecd2653e537bdc74e6b396e6c517f6">More...</a><br /></td></tr>
<tr class="separator:a9eecd2653e537bdc74e6b396e6c517f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60e72ad27f51f2181316e8adee18708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#af60e72ad27f51f2181316e8adee18708">set_directory_only</a> (bool <a class="el" href="classfsw_1_1monitor.html#a1d033d47e3f239aa3c3f73d269aff1b3">directory_only</a>)</td></tr>
<tr class="memdesc:af60e72ad27f51f2181316e8adee18708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watch directories only.  <a href="#af60e72ad27f51f2181316e8adee18708">More...</a><br /></td></tr>
<tr class="separator:af60e72ad27f51f2181316e8adee18708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce65ac297346366c70711e6eb1b3936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a2ce65ac297346366c70711e6eb1b3936">add_filter</a> (const <a class="el" href="structfsw_1_1monitor__filter.html">monitor_filter</a> &amp;filter)</td></tr>
<tr class="memdesc:a2ce65ac297346366c70711e6eb1b3936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a path filter.  <a href="#a2ce65ac297346366c70711e6eb1b3936">More...</a><br /></td></tr>
<tr class="separator:a2ce65ac297346366c70711e6eb1b3936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371a97482af66baf500eec6e3805ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a4371a97482af66baf500eec6e3805ad4">set_filters</a> (const std::vector&lt; <a class="el" href="structfsw_1_1monitor__filter.html">monitor_filter</a> &gt; &amp;filters)</td></tr>
<tr class="memdesc:a4371a97482af66baf500eec6e3805ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path filters.  <a href="#a4371a97482af66baf500eec6e3805ad4">More...</a><br /></td></tr>
<tr class="separator:a4371a97482af66baf500eec6e3805ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8460649e6589a5681b5a71e34607e55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a8460649e6589a5681b5a71e34607e55c">set_follow_symlinks</a> (bool follow)</td></tr>
<tr class="memdesc:a8460649e6589a5681b5a71e34607e55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow symlinks.  <a href="#a8460649e6589a5681b5a71e34607e55c">More...</a><br /></td></tr>
<tr class="separator:a8460649e6589a5681b5a71e34607e55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e5d8f86df5846dd053855c61982159"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a53e5d8f86df5846dd053855c61982159">get_context</a> () const </td></tr>
<tr class="memdesc:a53e5d8f86df5846dd053855c61982159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the context data.  <a href="#a53e5d8f86df5846dd053855c61982159">More...</a><br /></td></tr>
<tr class="separator:a53e5d8f86df5846dd053855c61982159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698593a1f1f47bb39f608f846ad42cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a698593a1f1f47bb39f608f846ad42cb2">set_context</a> (void *<a class="el" href="classfsw_1_1monitor.html#a31f7a7bde76c8b4487862298395a485e">context</a>)</td></tr>
<tr class="memdesc:a698593a1f1f47bb39f608f846ad42cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the context data.  <a href="#a698593a1f1f47bb39f608f846ad42cb2">More...</a><br /></td></tr>
<tr class="separator:a698593a1f1f47bb39f608f846ad42cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8394127e75863569f24041a5bdcb9cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5">start</a> ()</td></tr>
<tr class="memdesc:a8394127e75863569f24041a5bdcb9cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the monitor.  <a href="#a8394127e75863569f24041a5bdcb9cd5">More...</a><br /></td></tr>
<tr class="separator:a8394127e75863569f24041a5bdcb9cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce0e3c082cdbf88a0375db168e7c609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609">stop</a> ()</td></tr>
<tr class="memdesc:a2ce0e3c082cdbf88a0375db168e7c609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the monitor.  <a href="#a2ce0e3c082cdbf88a0375db168e7c609">More...</a><br /></td></tr>
<tr class="separator:a2ce0e3c082cdbf88a0375db168e7c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19062aa388994721b0d812bbc3b9e66e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a19062aa388994721b0d812bbc3b9e66e">is_running</a> ()</td></tr>
<tr class="memdesc:a19062aa388994721b0d812bbc3b9e66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the monitor is running.  <a href="#a19062aa388994721b0d812bbc3b9e66e">More...</a><br /></td></tr>
<tr class="separator:a19062aa388994721b0d812bbc3b9e66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ebf441240e1ee4731af2a718611343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#af2ebf441240e1ee4731af2a718611343">add_event_type_filter</a> (const <a class="el" href="structfsw__event__type__filter.html">fsw_event_type_filter</a> &amp;filter)</td></tr>
<tr class="memdesc:af2ebf441240e1ee4731af2a718611343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event type filter.  <a href="#af2ebf441240e1ee4731af2a718611343">More...</a><br /></td></tr>
<tr class="separator:af2ebf441240e1ee4731af2a718611343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73074d4f9258f7b964c4d327375db482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a73074d4f9258f7b964c4d327375db482">set_event_type_filters</a> (const std::vector&lt; <a class="el" href="structfsw__event__type__filter.html">fsw_event_type_filter</a> &gt; &amp;filters)</td></tr>
<tr class="memdesc:a73074d4f9258f7b964c4d327375db482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the event type filters.  <a href="#a73074d4f9258f7b964c4d327375db482">More...</a><br /></td></tr>
<tr class="separator:a73074d4f9258f7b964c4d327375db482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9833f7d8140be86f0c9ff60f91045848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a9833f7d8140be86f0c9ff60f91045848">set_watch_access</a> (bool access)</td></tr>
<tr class="memdesc:a9833f7d8140be86f0c9ff60f91045848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor file access.  <a href="#a9833f7d8140be86f0c9ff60f91045848">More...</a><br /></td></tr>
<tr class="separator:a9833f7d8140be86f0c9ff60f91045848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8376e25dd7e8de9bc68a7e3bfe17d763"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a8376e25dd7e8de9bc68a7e3bfe17d763">accept_event_type</a> (<a class="el" href="cevent_8h.html#abc60ab95628a5c475a0c5cf92c33e7d4">fsw_event_flag</a> event_type) const </td></tr>
<tr class="memdesc:a8376e25dd7e8de9bc68a7e3bfe17d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an event should be accepted.  <a href="#a8376e25dd7e8de9bc68a7e3bfe17d763">More...</a><br /></td></tr>
<tr class="separator:a8376e25dd7e8de9bc68a7e3bfe17d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad743e6f6a4543c0f29ffe2b8133c7e2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ad743e6f6a4543c0f29ffe2b8133c7e2e">accept_path</a> (const std::string &amp;path) const </td></tr>
<tr class="memdesc:ad743e6f6a4543c0f29ffe2b8133c7e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a path should be accepted.  <a href="#ad743e6f6a4543c0f29ffe2b8133c7e2e">More...</a><br /></td></tr>
<tr class="separator:ad743e6f6a4543c0f29ffe2b8133c7e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b87fcf10507837f07aaca85de50705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ae4b87fcf10507837f07aaca85de50705">accept_path</a> (const char *path) const </td></tr>
<tr class="memdesc:ae4b87fcf10507837f07aaca85de50705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a path should be accepted.  <a href="#ae4b87fcf10507837f07aaca85de50705">More...</a><br /></td></tr>
<tr class="separator:ae4b87fcf10507837f07aaca85de50705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5762f5a50264a3717490f98a631b0616"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a5762f5a50264a3717490f98a631b0616">notify_events</a> (const std::vector&lt; <a class="el" href="classfsw_1_1event.html">event</a> &gt; &amp;events) const </td></tr>
<tr class="memdesc:a5762f5a50264a3717490f98a631b0616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify change events.  <a href="#a5762f5a50264a3717490f98a631b0616">More...</a><br /></td></tr>
<tr class="separator:a5762f5a50264a3717490f98a631b0616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c71a55a6e1116f05e08f42b55e9440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ab0c71a55a6e1116f05e08f42b55e9440">notify_overflow</a> (const std::string &amp;path) const </td></tr>
<tr class="memdesc:ab0c71a55a6e1116f05e08f42b55e9440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify an overflow event.  <a href="#ab0c71a55a6e1116f05e08f42b55e9440">More...</a><br /></td></tr>
<tr class="separator:ab0c71a55a6e1116f05e08f42b55e9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599efd1394444779abbbc6741bd39195"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="cevent_8h.html#abc60ab95628a5c475a0c5cf92c33e7d4">fsw_event_flag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a599efd1394444779abbbc6741bd39195">filter_flags</a> (const <a class="el" href="classfsw_1_1event.html">event</a> &amp;evt) const </td></tr>
<tr class="memdesc:a599efd1394444779abbbc6741bd39195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter event types.  <a href="#a599efd1394444779abbbc6741bd39195">More...</a><br /></td></tr>
<tr class="separator:a599efd1394444779abbbc6741bd39195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fb795d1088950bc741689865d2b689"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689">run</a> ()=0</td></tr>
<tr class="memdesc:ae5fb795d1088950bc741689865d2b689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute monitor loop.  <a href="#ae5fb795d1088950bc741689865d2b689">More...</a><br /></td></tr>
<tr class="separator:ae5fb795d1088950bc741689865d2b689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7268e813faa0068db46c0aca018594fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a7268e813faa0068db46c0aca018594fe">on_stop</a> ()</td></tr>
<tr class="memdesc:a7268e813faa0068db46c0aca018594fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an implementation-specific stop handler.  <a href="#a7268e813faa0068db46c0aca018594fe">More...</a><br /></td></tr>
<tr class="separator:a7268e813faa0068db46c0aca018594fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2145c195fd74240392c276c1e05f8a1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a2145c195fd74240392c276c1e05f8a1a">paths</a></td></tr>
<tr class="memdesc:a2145c195fd74240392c276c1e05f8a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of paths to watch.  <a href="#a2145c195fd74240392c276c1e05f8a1a">More...</a><br /></td></tr>
<tr class="separator:a2145c195fd74240392c276c1e05f8a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925ec3c00d81964b188ab90550b92a47"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a925ec3c00d81964b188ab90550b92a47">properties</a></td></tr>
<tr class="memdesc:a925ec3c00d81964b188ab90550b92a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of custom properties.  <a href="#a925ec3c00d81964b188ab90550b92a47">More...</a><br /></td></tr>
<tr class="separator:a925ec3c00d81964b188ab90550b92a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb98ec82dfb122c73d51118ced25c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefsw.html#aeec974e61cf25175d0e530cd3f504f81">FSW_EVENT_CALLBACK</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#aaeb98ec82dfb122c73d51118ced25c4f">callback</a></td></tr>
<tr class="memdesc:aaeb98ec82dfb122c73d51118ced25c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to which change events should be notified.  <a href="#aaeb98ec82dfb122c73d51118ced25c4f">More...</a><br /></td></tr>
<tr class="separator:aaeb98ec82dfb122c73d51118ced25c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f7a7bde76c8b4487862298395a485e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f7a7bde76c8b4487862298395a485e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a31f7a7bde76c8b4487862298395a485e">context</a> = nullptr</td></tr>
<tr class="memdesc:a31f7a7bde76c8b4487862298395a485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to context data that will be passed to the <a class="el" href="classfsw_1_1monitor.html#aaeb98ec82dfb122c73d51118ced25c4f" title="Callback to which change events should be notified. ">monitor::callback</a>. <br /></td></tr>
<tr class="separator:a31f7a7bde76c8b4487862298395a485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd94758dcbd77755b9466a5adbcaec3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dd94758dcbd77755b9466a5adbcaec3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a8dd94758dcbd77755b9466a5adbcaec3">latency</a> = 1.0</td></tr>
<tr class="memdesc:a8dd94758dcbd77755b9466a5adbcaec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latency of the monitor. <br /></td></tr>
<tr class="separator:a8dd94758dcbd77755b9466a5adbcaec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ffa5236ceca6bc9610f03104b03f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a31ffa5236ceca6bc9610f03104b03f1b">fire_idle_event</a> = false</td></tr>
<tr class="memdesc:a31ffa5236ceca6bc9610f03104b03f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, the monitor will notify an event when idle.  <a href="#a31ffa5236ceca6bc9610f03104b03f1b">More...</a><br /></td></tr>
<tr class="separator:a31ffa5236ceca6bc9610f03104b03f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8aa9642148d6ff7e6777430cd6ce6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a8aa9642148d6ff7e6777430cd6ce6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a2a8aa9642148d6ff7e6777430cd6ce6a">allow_overflow</a> = false</td></tr>
<tr class="memdesc:a2a8aa9642148d6ff7e6777430cd6ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, queue overflow events will be notified to the caller, otherwise the monitor will throw a <a class="el" href="classfsw_1_1libfsw__exception.html" title="Base exception of the libfswatch library. ">libfsw_exception</a>. <br /></td></tr>
<tr class="separator:a2a8aa9642148d6ff7e6777430cd6ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63ee8c36aeffd3ecb00f9a26632b8f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63ee8c36aeffd3ecb00f9a26632b8f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ae63ee8c36aeffd3ecb00f9a26632b8f5">recursive</a> = false</td></tr>
<tr class="memdesc:ae63ee8c36aeffd3ecb00f9a26632b8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, directories will be scanned recursively. <br /></td></tr>
<tr class="separator:ae63ee8c36aeffd3ecb00f9a26632b8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453398a3f8a6289399f98c969bdaec2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453398a3f8a6289399f98c969bdaec2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a453398a3f8a6289399f98c969bdaec2a">follow_symlinks</a> = false</td></tr>
<tr class="memdesc:a453398a3f8a6289399f98c969bdaec2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, symbolic links are followed. <br /></td></tr>
<tr class="separator:a453398a3f8a6289399f98c969bdaec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d033d47e3f239aa3c3f73d269aff1b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d033d47e3f239aa3c3f73d269aff1b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a1d033d47e3f239aa3c3f73d269aff1b3">directory_only</a> = false</td></tr>
<tr class="memdesc:a1d033d47e3f239aa3c3f73d269aff1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether only directories should be monitored. <br /></td></tr>
<tr class="separator:a1d033d47e3f239aa3c3f73d269aff1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cec9b23e01aa3d04253174023c279a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66cec9b23e01aa3d04253174023c279a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a66cec9b23e01aa3d04253174023c279a">watch_access</a> = false</td></tr>
<tr class="memdesc:a66cec9b23e01aa3d04253174023c279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether file access should be watched. <br /></td></tr>
<tr class="separator:a66cec9b23e01aa3d04253174023c279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77889a6a42e5c00699caeba0c2fb40e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77889a6a42e5c00699caeba0c2fb40e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#ae77889a6a42e5c00699caeba0c2fb40e">running</a> = false</td></tr>
<tr class="memdesc:ae77889a6a42e5c00699caeba0c2fb40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the monitor is in the running state. <br /></td></tr>
<tr class="separator:ae77889a6a42e5c00699caeba0c2fb40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d5925d830e224a250370b38d4206cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54d5925d830e224a250370b38d4206cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a54d5925d830e224a250370b38d4206cf">should_stop</a> = false</td></tr>
<tr class="memdesc:a54d5925d830e224a250370b38d4206cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the monitor should preemptively stop. <br /></td></tr>
<tr class="separator:a54d5925d830e224a250370b38d4206cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb766bae199fe17c7d0c441f4cff4ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecb766bae199fe17c7d0c441f4cff4ec"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec">run_mutex</a></td></tr>
<tr class="memdesc:aecb766bae199fe17c7d0c441f4cff4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used to serialize access to the monitor state from multiple threads. <br /></td></tr>
<tr class="separator:aecb766bae199fe17c7d0c441f4cff4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2317cd76ea75c72e52a2170bf747d339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2317cd76ea75c72e52a2170bf747d339"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfsw_1_1monitor.html#a2317cd76ea75c72e52a2170bf747d339">notify_mutex</a></td></tr>
<tr class="memdesc:a2317cd76ea75c72e52a2170bf747d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used to serialize access to the <a class="el" href="classfsw_1_1monitor.html#a5762f5a50264a3717490f98a631b0616" title="Notify change events. ">notify_events()</a> method. <br /></td></tr>
<tr class="separator:a2317cd76ea75c72e52a2170bf747d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class of all monitors. </p>
<p>The <a class="el" href="classfsw_1_1monitor.html" title="Base class of all monitors. ">fsw::monitor</a> class is the base class of all monitors. This class encapsulates the common functionality of a monitor:</p>
<ul>
<li>Accessors to configuration parameters.</li>
<li><a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5" title="Start the monitor. ">start()</a> and <a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> lifecycle.</li>
<li>Event filtering.</li>
<li>Event notification to user-provided callback function.</li>
</ul>
<p>Since some methods are designed to be called from different threads, this class provides an internal mutex (<a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>) that implementors should lock on when accessing shared state. The mutex is available only when <code>HAVE_CXX_MUTEX</code> is defined.</p>
<p>At least the following tasks must be performed to implement a monitor:</p>
<ul>
<li>Providing an implementation of the <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> method.</li>
<li>Providing an implementation of the <a class="el" href="classfsw_1_1monitor.html#a7268e813faa0068db46c0aca018594fe" title="Execute an implementation-specific stop handler. ">on_stop()</a> method if the monitor cannot be stopped cooperatively from the <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> method.</li>
</ul>
<p>A basic monitor needs to implement the <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> method, whose skeleton is often similar to the following: </p><pre class="fragment">void run()
{
  initialize_api();

  for (;;)
  {
    #ifdef HAVE_CXX_MUTEX
      unique_lock&lt;mutex&gt; run_guard(run_mutex);
      if (should_stop) break;
      run_guard.unlock();
    #endif

    scan_paths();
    wait_for_events();

    vector&lt;change_events&gt; evts = get_changes();
    vector&lt;event&gt; events;

    for (auto &amp; evt : evts)
    {
      if (accept(evt.get_path))
      {
        events.push_back({event from evt});
      }
    }

    if (events.size()) notify_events(events);
  }

  terminate_api();
}
</pre><p>Despite being a minimal implementation, it performs all the tasks commonly performed by a monitor:</p>
<ul>
<li>It initializes the API it uses to detect file system change events.</li>
<li>It enters a loop, often infinite, where change events are waited for.</li>
<li>If <code>HAVE_CXX_MUTEX</code> is defined, it locks on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a> to check whether <a class="el" href="classfsw_1_1monitor.html#a54d5925d830e224a250370b38d4206cf" title="Flag indicating whether the monitor should preemptively stop. ">monitor::should_stop</a> is set to <code>true</code>. If it is, the monitor breaks the loop to return from <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> as soon as possible.</li>
<li>It scans the paths that must be observed: this step might be necessary for example because some path may not have existed during the previous iteration of the loop, or because some API may require the user to re-register a watch on a path after events are retrieved.</li>
<li>Events are waited for and the wait should respect the specified <em>latency</em>.</li>
<li>Events are <em>filtered</em> to exclude those referring to paths that do not satisfy the configured filters.</li>
<li>The <a class="el" href="classfsw_1_1monitor.html#a5762f5a50264a3717490f98a631b0616" title="Notify change events. ">notify_events()</a> method is called to filter the event types and notify the caller. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aba09c75eb425a34848cf1511a5f2bc57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fsw::monitor::monitor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefsw.html#aeec974e61cf25175d0e530cd3f504f81">FSW_EVENT_CALLBACK</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a monitor watching the specified <code>paths</code>. </p>
<p>The monitor will notify change events to the specified <code>callback</code>, passing it the pointer to the specified <code>context</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>The list of paths to watch. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback to which change events will be notified. The callback cannot be null, otherwise a <a class="el" href="classfsw_1_1libfsw__exception.html" title="Base exception of the libfswatch library. ">libfsw_exception</a> will be thrown. </td></tr>
    <tr><td class="paramname">context</td><td>An optional pointer to context data. The monitor stores a copy of this pointer to pass it to the <code>callback</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1b082c84d771f601c98240ed6aa8775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fsw::monitor::~monitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs a monitor instance. </p>
<p>This destructor performs the following operations:</p>
<ul>
<li>Stops the monitor.</li>
<li>Frees the compiled regular expression of the path filters, if any.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Destroying a monitor in the <em>running</em> state results in undefined behaviour.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8376e25dd7e8de9bc68a7e3bfe17d763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fsw::monitor::accept_event_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cevent_8h.html#abc60ab95628a5c475a0c5cf92c33e7d4">fsw_event_flag</a>&#160;</td>
          <td class="paramname"><em>event_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether an event should be accepted. </p>
<p>This function checks <code>event_type</code> against the event type filters of the monitor to determine whether it should be <em>accepted</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The event type to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the event is accepted, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad743e6f6a4543c0f29ffe2b8133c7e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fsw::monitor::accept_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a path should be accepted. </p>
<p>This function checks <code>path</code> against the path filters of the monitor to determine whether it should be <em>accepted</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the path is accepted, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b87fcf10507837f07aaca85de50705"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fsw::monitor::accept_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a path should be accepted. </p>
<p>This function checks <code>path</code> against the path filters of the monitor to determine whether it should be <em>accepted</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the path is accepted, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af2ebf441240e1ee4731af2a718611343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::add_event_type_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfsw__event__type__filter.html">fsw_event_type_filter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event type filter. </p>
<p>Adds a <a class="el" href="structfsw__event__type__filter.html" title="Event type filter. ">fsw_event_type_filter</a> instance to filter events by <em>type</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The event type filter to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ce65ac297346366c70711e6eb1b3936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::add_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfsw_1_1monitor__filter.html">monitor_filter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a path filter. </p>
<p>This function adds a <a class="el" href="structfsw_1_1monitor__filter.html" title="Path filters used to accept or reject file change events. ">monitor_filter</a> instance instance to the filter list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The filter to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a599efd1394444779abbbc6741bd39195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="cevent_8h.html#abc60ab95628a5c475a0c5cf92c33e7d4">fsw_event_flag</a> &gt; fsw::monitor::filter_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfsw_1_1event.html">event</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter event types. </p>
<p>This function filters the event types of an event leaving only the types allowed by the configured filters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>The event whose types must be filtered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the acceptable events. </dd></dl>

</div>
</div>
<a class="anchor" id="a53e5d8f86df5846dd053855c61982159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fsw::monitor::get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the context data. </p>
<p>This function gets the pointer to the context data that is passed to the callback by the monitor.</p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the context data. </dd></dl>

</div>
</div>
<a class="anchor" id="adcdac1c160c6f4d02aeeee98f9c6afc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string fsw::monitor::get_property </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a property. </p>
<p>This method gets the value of the property <code>name</code>. If the property <code>name</code> is not set, this method returns an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property. </dd></dl>

</div>
</div>
<a class="anchor" id="a19062aa388994721b0d812bbc3b9e66e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsw::monitor::is_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the monitor is running. </p>
<p>State is checked thread-safely locking on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the monitor is running, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5762f5a50264a3717490f98a631b0616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::notify_events </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfsw_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify change events. </p>
<p>This function notifies change events using the provided callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#aba09c75eb425a34848cf1511a5f2bc57" title="Constructs a monitor watching the specified paths. ">monitor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c71a55a6e1116f05e08f42b55e9440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::notify_overflow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify an overflow event. </p>
<p>This function notifies an overflow event using the provided callback.</p>
<dl class="section warning"><dt>Warning</dt><dd>Experiencing an overflow and the ability to notify it is an implementation-defined behaviour.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#aba09c75eb425a34848cf1511a5f2bc57" title="Constructs a monitor watching the specified paths. ">monitor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7268e813faa0068db46c0aca018594fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::on_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute an implementation-specific stop handler. </p>
<p>This function is executed by the <a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> method, after requesting the monitor to stop. This handler is required if the thread running <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> is not able to preemptively stop its execution by checking the <a class="el" href="classfsw_1_1monitor.html#a54d5925d830e224a250370b38d4206cf" title="Flag indicating whether the monitor should preemptively stop. ">monitor::should_stop</a> flag.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classfsw_1_1fsevents__monitor.html#a19e505e395a2a5dbef427fdcd10f45f8">fsw::fsevents_monitor</a>.</p>

</div>
</div>
<a class="anchor" id="ae5fb795d1088950bc741689865d2b689"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fsw::monitor::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute monitor loop. </p>
<p>This function implements the monitor event watching logic. This function is called from <a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5" title="Start the monitor. ">start()</a> and it is executed on its thread. This function should <em>block</em> until the monitoring loop terminates: when it returns, the monitor is marked as stopped.</p>
<p>This function should cooperatively check the <a class="el" href="classfsw_1_1monitor.html#a54d5925d830e224a250370b38d4206cf" title="Flag indicating whether the monitor should preemptively stop. ">monitor::should_stop</a> field locking <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a> and return if set to <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5" title="Start the monitor. ">start()</a> </dd>
<dd>
<a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> </dd></dl>

<p>Implemented in <a class="el" href="classfsw_1_1fen__monitor.html#af4090b5d6a8dc1a5ff38aa8860dcb108">fsw::fen_monitor</a>, <a class="el" href="classfsw_1_1inotify__monitor.html#ac4a885260263600dec6293f7913f7909">fsw::inotify_monitor</a>, <a class="el" href="classfsw_1_1kqueue__monitor.html#ad6b0bc678b6108bc1f019b925ee785fb">fsw::kqueue_monitor</a>, <a class="el" href="classfsw_1_1windows__monitor.html#a693968bf6449248cf3887847a45485a7">fsw::windows_monitor</a>, <a class="el" href="classfsw_1_1fsevents__monitor.html#a314d7d7417d5185d0e84120d3496e960">fsw::fsevents_monitor</a>, and <a class="el" href="classfsw_1_1poll__monitor.html#a5df3f6bfc3a4b0f6e7defbb2fd02972a">fsw::poll_monitor</a>.</p>

</div>
</div>
<a class="anchor" id="a599416921f439d4a02c156adee1c3643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_allow_overflow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overflow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify buffer overflows as change events. </p>
<p>If this flag is set, the monitor will report a monitor buffer overflow as a change event of type fsw_event_flag::Overflow.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour associated with this flag depends on the implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overflow</td><td><code>true</code> if overflow should be notified, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a698593a1f1f47bb39f608f846ad42cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_context </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the context data. </p>
<p>This function sets the pointer to the <em>context data</em>. The context data is opaque data that the monitor passes to the event callback.</p>
<dl class="section warning"><dt>Warning</dt><dd>The monitor stores the pointer to the context data throughout its life. The caller must ensure it points to valid data until the monitor is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af60e72ad27f51f2181316e8adee18708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_directory_only </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directory_only</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Watch directories only. </p>
<p>This function sets the directory only flag to the specified value. If this flag is set, then the monitor will only watch directories during a recursive scan. This functionality is only supported by monitors whose backend fires change events on a directory when one its children is changed. If a monitor backend does not support this functionality, the flag is ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour associated with this flag depends on the implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory_only</td><td><code>true</code> if only directories should be watched, <code>flase</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73074d4f9258f7b964c4d327375db482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_event_type_filters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structfsw__event__type__filter.html">fsw_event_type_filter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the event type filters. </p>
<p>This function sets the list of event type filters, substituting existing filters if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>The filters to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4371a97482af66baf500eec6e3805ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_filters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structfsw_1_1monitor__filter.html">monitor_filter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path filters. </p>
<p>This function sets the list of path filters, substituting existing filters if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>The filters to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab803cabf3d393c789338e5b7385e48e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_fire_idle_event </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_idle_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <em>fire idle event</em> flag. </p>
<p>When <code>true</code>, the <em>fire idle event</em> flag instructs the monitor to fire a fake event at the event of an <em>idle</em> cycle. An idle cycle is a period of time whose length is 110% of the <a class="el" href="classfsw_1_1monitor.html#a8dd94758dcbd77755b9466a5adbcaec3" title="Latency of the monitor. ">monitor::latency</a> where no change events were detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fire_idle_event</td><td><code>true</code> if idle events should be fired, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8460649e6589a5681b5a71e34607e55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_follow_symlinks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>follow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Follow symlinks. </p>
<p>This function sets the follow_symlinks flag of the monitor to indicate whether the monitor should follow symbolic links or observe the links themselves.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour associated with this flag depends on the implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">follow</td><td><code>true</code> if symbolic links should be followed, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5121f8f7accc77a212853b6d84ca4fe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_latency </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the latency. </p>
<p>This method sets the <em>latency</em> of the monitor to <code>latency</code>. The latency is a positive number that indicates to a monitor implementation how often events must be retrieved or waited for: the shortest the latency, the quicker events are processed.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour associated with this flag depends on the implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latency</td><td>The latency value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9209992c164ca241f32f3f0435a6ae39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_properties </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the custom properties. </p>
<p>This method <em>replaces</em> all the existing properties using the pairs contained into <code>options</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The map containing the properties to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a747619157af3f23f0f4f48e438af17a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a custom property. </p>
<p>This method sets the custom property <code>name</code> to <code>value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the property. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9eecd2653e537bdc74e6b396e6c517f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_recursive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively scan subdirectories. </p>
<p>This function sets the recursive flag of the monitor to indicate whether the monitor should recursively observe the contents of directories. The behaviour associated with this flag is an implementation-specific detail. This class only stores the value of the flag.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour associated with this flag depends on the implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recursive</td><td><code>true</code> if directories should be recursively, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9833f7d8140be86f0c9ff60f91045848"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::set_watch_access </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monitor file access. </p>
<dl class="section warning"><dt>Warning</dt><dd>The ability of monitoring file access depends on a monitor implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8394127e75863569f24041a5bdcb9cd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the monitor. </p>
<p>The monitor status is marked as <em>running</em> and it starts watching for change events. This function performs the following tasks:</p>
<ul>
<li>Atomically marks the thread state as <em>running</em>, locking on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>.</li>
<li>Calls the <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> function: the <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a> is <b>not</b> locked during this call.</li>
<li>When <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> returns, it atomically marks the thread state as <em>stopped</em>, locking on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>.</li>
</ul>
<p>This call does <em>not</em> return until the monitor is stopped and events are notified from its thread.</p>
<p>State changes are performed thread-safely locking on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> </dd>
<dd>
<a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ce0e3c082cdbf88a0375db168e7c609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw::monitor::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the monitor. </p>
<p>This function asks the monitor to stop. Since <a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5" title="Start the monitor. ">start()</a> is designed to execute the monitoring loop in its thread and to not return until the monitor is stopped, <a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> is designed to be called from another thread. <a class="el" href="classfsw_1_1monitor.html#a2ce0e3c082cdbf88a0375db168e7c609" title="Stop the monitor. ">stop()</a> is a cooperative signal that must be handled in an implementation-specific way in the <a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> function.</p>
<p>State changes are performed thread-safely locking on <a class="el" href="classfsw_1_1monitor.html#aecb766bae199fe17c7d0c441f4cff4ec" title="Mutex used to serialize access to the monitor state from multiple threads. ">monitor::run_mutex</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#ae5fb795d1088950bc741689865d2b689" title="Execute monitor loop. ">run()</a> </dd>
<dd>
<a class="el" href="classfsw_1_1monitor.html#a8394127e75863569f24041a5bdcb9cd5" title="Start the monitor. ">start()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aaeb98ec82dfb122c73d51118ced25c4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefsw.html#aeec974e61cf25175d0e530cd3f504f81">FSW_EVENT_CALLBACK</a>* fsw::monitor::callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback to which change events should be notified. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#aba09c75eb425a34848cf1511a5f2bc57" title="Constructs a monitor watching the specified paths. ">monitor::monitor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a31ffa5236ceca6bc9610f03104b03f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fsw::monitor::fire_idle_event = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>true</code>, the monitor will notify an event when idle. </p>
<p>An idle cycle is long as 110% of the <a class="el" href="classfsw_1_1monitor.html#a8dd94758dcbd77755b9466a5adbcaec3" title="Latency of the monitor. ">monitor::latency</a> value. </p>

</div>
</div>
<a class="anchor" id="a2145c195fd74240392c276c1e05f8a1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; fsw::monitor::paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of paths to watch. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#aba09c75eb425a34848cf1511a5f2bc57" title="Constructs a monitor watching the specified paths. ">monitor::monitor()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a925ec3c00d81964b188ab90550b92a47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; fsw::monitor::properties</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of custom properties. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfsw_1_1monitor.html#a747619157af3f23f0f4f48e438af17a5" title="Sets a custom property. ">monitor::set_property()</a> </dd>
<dd>
<a class="el" href="classfsw_1_1monitor.html#a9209992c164ca241f32f3f0435a6ae39" title="Sets the custom properties. ">monitor::set_properties()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libfswatch/c++/<a class="el" href="monitor_8hpp_source.html">monitor.hpp</a></li>
<li>libfswatch/c++/monitor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
